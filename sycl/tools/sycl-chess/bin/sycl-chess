#!/bin/bash
#
# TODO: A lovely ðŸ’ž description when this is working to a reasonable level of
# stability
#
# Arguments:
# $1 == Cardanos bin directory where the xilinx wrapper scripts to chess tools
#       (xchess*) reside amongst other things
# $2 == path to the clang driver that's executing the shell script (e.g.
#        your compiled Clang's build/bin)
# $3 == The name of the source file without file extensions or temporary
#       manglings, mostly used to generate some intermediate file names
# $4 == The initial input file name, currently a .o file that's actually a .bc
#       file in disguise
# $5 == The systems temporary directory where we'll deposit some intermediate
#       files
# $6 == The name we wish to give our final output .xcl binary, important that it
#       is consistent with what the driver expects it to be.

usage() { echo sycl-chess: error: $2 >&2; exit $1; }

if [[ -z "$1" ]]; then
  usage 1 "no Cardano bin directory containing xchesscc"
fi

if [[ -z "$2" ]]; then
  usage 2 "no driver path specified"
fi

if [[ -z "$3" ]]; then
  usage 3 "no source file name"
fi

if [[ -z "$4" ]]; then
  usage 4 "no input file name"
fi

if [[ -z "$5" ]]; then
  usage 5 "no temporary directory specified"
fi

if [[ -z "$6" ]]; then
  usage 6 "no final output file specified"
fi

# Setup Cardano related env variables
export CARDANO_BIN_PATH_DIR="$1"
if [[ ! -d "$CARDANO_BIN_PATH_DIR" ]]; then
  usage 7 "path to Cardano bin directory is not a valid directory"
else
  export XCHESSCC="$CARDANO_BIN_PATH_DIR/xchesscc"
  if [[ ! -f "$XCHESSCC" ]]; then
    usage 8 "could not find Cardanos xchesscc in $CARDANO_BIN_PATH_DIR"
  fi

  export CARDANO_LIB_DIR="$CARDANO_BIN_PATH_DIR/../data/cervino/lib/"
  if [[ ! -d "$CARDANO_LIB_DIR" ]]; then
    usage 9 "cardano lib directory not found"
  fi
fi

# Setup Clang/LLVM related env variables
export DRIVER_PATH_DIR="$2"
if [[ ! -d "$DRIVER_PATH_DIR" ]]; then
  usage 10 "path to driver directory is not a valid directory"
else
  export OPT="$DRIVER_PATH_DIR/opt"
  if [[ ! -f "$OPT" ]]; then
    usage 11 "no llvm opt executable found in $DRIVER_PATH_DIR"
  fi
fi

# excluding file extension e.g. .cpp
export SOURCE_FILE_NAME="$3"
# input file name including extensions and path
export INPUT_FILE_NAME="$4"
# Should point to whatever Clang has decided is the temporary directory
export CLANG_TEMPORARY_DIR="$5"
# output file name including extensions and path
export OUTPUT_FILE_NAME="$6"

if [[ ! -d "$CLANG_TEMPORARY_DIR" ]]; then
  usage 12 "the path given for the temporary directory is an invalid directory"
fi

# Push chess scripts to the front of the path, they're placed inside of a
# chesswrapper folder so we don't have to add the bin to the path. Doing that
# may run the risk of breaking chess tools in weird ways (e.g. finding the
# incorrect assembler).
export PATH=$DRIVER_PATH_DIR/chesswrappers:$PATH

# Weirdly the +w argument of the chesscc compiler doesn't dump any of the
# output files into the work directory you supply... it seems to just dump a
# ton of other temporary files there! Useful for debugging perhaps, but not
# useful to keep a sane temporary directory when compiling for 400 tiles
export SOURCE_TEMPORARY_DIR="$CLANG_TEMPORARY_DIR/${SOURCE_FILE_NAME}_SYCLChessTmp"

if [ ! -d "$SOURCE_TEMPORARY_DIR" ]; then
  mkdir $SOURCE_TEMPORARY_DIR
fi

# -O3 causes over optimization with a simple hello_world.cpp and we end up
# with a trap...
# Run Opt pass to convert our IR into something the chess toolchain can support
$OPT -S -O3 -kernelPropGen  -instnamer -xoccIRDowngrader -ChessMassage \
  "$INPUT_FILE_NAME" -o \
  "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernels-optimized.ll"

# Our bash file containing kernel property environment variables is placed in
# the systems temporary directory (or wherever the Clang driver is told is the
# temporary directory) and is postfixed with the source files name. It's
# generated by the kernelPropertiesGen OPT pass.
mv "$CLANG_TEMPORARY_DIR/KernelProperties_${SOURCE_FILE_NAME}.bash" \
   "$SOURCE_TEMPORARY_DIR/KernelProperties_${SOURCE_FILE_NAME}.bash"

source "$SOURCE_TEMPORARY_DIR/KernelProperties_${SOURCE_FILE_NAME}.bash"

# AI Engine .o file containing all kernels for the module
$XCHESSCC +P $(nproc) -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f -c \
  -o "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernel_module.o" \
  "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernels-optimized.ll"

# A function we can fork into child processes to achieve some form of
# parallelism at a higher level than chess itself provides with it's own
# paralleism via +P.
# This is the reason everything is lazily exported as we invoke this via xargs
# and wish to import/inject this scripts environment into its subprocess
# invocations
#
# This is the biggest slowdown in the compilation pipeline right now.
# TODO: The next simplest speedup is to swap to Peano which is several times
# quicker after that if it's still slow or if we do not wish to/cannot swap to
# Peano eventually working out duplicate kernels and removing them is the next
# step. Even if templated most sane kernel code is unlikely to have 400
# variations, if it does then may the implementer fall apon the sword of their
# own making!
chess_kernel_compile () {
    echo "Linking Kernel: $0"
    echo "Tile Main File: $SOURCE_TEMPORARY_DIR/$0.cpp"

    # TODO: Look into the fact that SemaSYCL generates the main files twice
    # once pre-linker phase and once after. This is probably normal behaviour
    # but we do not want to be unable to clean up those files and it may result
    # in some unusual behaviour longterm
    mv "$CLANG_TEMPORARY_DIR/$0.cpp" "$SOURCE_TEMPORARY_DIR/$0.cpp"

    $XCHESSCC -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f -c \
      -o "$SOURCE_TEMPORARY_DIR/$0.main.o" "$SOURCE_TEMPORARY_DIR/$0.cpp"

    $XCHESSCC -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f \
      +l$DRIVER_PATH_DIR/chesswrappers/linker_script.bcf \
      -o "$SOURCE_TEMPORARY_DIR/$0.elf.o" \
      "$SOURCE_TEMPORARY_DIR/$0.main.o" \
      "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernel_module.o"
}

# export the bash function so xargs can use it
export -f chess_kernel_compile

# For the number of arguments in KERNEL_NAME_ARRAY, invoke xargs for each
# and only consume 1 argument per invocation. This is passed in as the $0'th
# variable. We invoke xargs for the maximum number of cores available on the
# system.
if [[ ! ${#KERNEL_NAME_ARRAY[@]} -eq 0 ]]; then
  echo "${KERNEL_NAME_ARRAY[@]}" | xargs -n1 -P$(nproc) \
    bash -c 'chess_kernel_compile "$@"'
fi

# Wait on all our spawned compilations to complete
wait

# Cat all the metadata and images into a file (essentially defining our own
# temporary packing format). This is perhaps not robust but it does the job for
# the moment.
# This is not parallelized in the compilation function as we want the file to be
# sequential or at least in the basic order defined in the loop. We do not want
# data races making the file format non-deterministic.
if [[ ! ${#KERNEL_NAME_ARRAY[@]} -eq 0 ]]; then
  LINKER_LIST=""
  for index in "${KERNEL_NAME_ARRAY[@]}"; do
    if [[ -n "$index" ]]; then
      # Name of ELF binary and kernel function that we will synch with
      # integration header to retrieve our binary, it will be packaged as part
      # of the final image data.
      # The name is also used by the Offload Wrapper to identify the image to
      # wrap into the host binary after its loaded into memory.
      echo "${index}" >> "$OUTPUT_FILE_NAME"
      # Size of file in bytes
      echo "`ls -lrt "$SOURCE_TEMPORARY_DIR/${index}.elf.o" | nawk '{print $5}'`" \
        >> "$OUTPUT_FILE_NAME"
      cat $SOURCE_TEMPORARY_DIR/${index}.elf.o >> "$OUTPUT_FILE_NAME"
    fi
  done
fi

# Dump a copy of the file containing all of the AIE binaries into another file
# so that we can introspect and in theory skip the AOC stage above, if
# we want to, by altering the script a little to comment out the compilation
# steps and inverting the copy, to copy the aie_images file to the output file.
# Useful for debugging the host <-> device side mapping and or offloading
# stages. Dumped in the basic temporary directory clang passes because we
# flatline all of the directory we use to output intermediate files.
cp "$OUTPUT_FILE_NAME"  "$CLANG_TEMPORARY_DIR/aie_images"

# Delete all temporary files generated by Chess and other tools, the clang
# compiler doesn't know what we generate in here so it has to be manually
# tracked and removed
rm -rf $SOURCE_TEMPORARY_DIR
