#!/bin/bash
#
# TODO: A lovely ðŸ’ž description when this is working to a reasonable level of
# stability
#
# Arguments:
# $1 == Cardanos bin directory where the xilinx wrapper scripts to chess tools
#       (xchess*) reside amongst other things
# $2 == path to the clang driver that's executing the shell script (e.g.
#        your compiled Clang's build/bin)
# $3 == The name of the source file without file extensions or temporary
#       manglings, mostly used to generate some intermediate file names
# $4 == The initial input file name, currently a .o file that's actually a .bc
#       file in disguise
# $5 == The systems temporary directory where we'll deposit some intermediate
#       files
# $6 == The name we wish to give our final output .xcl binary, important that it
#       is consistent with what the driver expects it to be.

usage() { echo sycl-chess: error: $2 >&2; exit $1; }

set -e
set -x
# export SHELLOPTS

if [[ -z "$1" ]]; then
  usage 1 "no Cardano bin directory containing xchesscc"
fi

if [[ -z "$2" ]]; then
  usage 2 "no driver path specified"
fi

if [[ -z "$3" ]]; then
  usage 3 "no source file name"
fi

if [[ -z "$4" ]]; then
  usage 4 "no input file name"
fi

if [[ -z "$5" ]]; then
  usage 5 "no temporary directory specified"
fi

if [[ -z "$6" ]]; then
  usage 6 "no final output file specified"
fi

# Setup Clang/LLVM related env variables
export DRIVER_PATH_DIR="$(realpath $2)"
if [[ ! -d "$DRIVER_PATH_DIR" ]]; then
  usage 10 "path to driver directory is not a valid directory"
else
  export OPT="$DRIVER_PATH_DIR/opt"
  if [[ ! -f "$OPT" ]]; then
    usage 11 "no llvm opt executable found in $DRIVER_PATH_DIR"
  fi
fi

# Setup Cardano related env variables
export CARDANO_BIN_PATH_DIR="$1"
if [[ ! -d "$CARDANO_BIN_PATH_DIR" ]]; then
  usage 7 "path to Cardano bin directory is not a valid directory"
else
  export UNWAPPED_XCHESSCC="$CARDANO_BIN_PATH_DIR/unwrapped/lnx64.o/xchesscc"
  if [[ ! -f "$UNWAPPED_XCHESSCC" ]]; then
    usage 8 "could not find Cardanos xchesscc in $CARDANO_BIN_PATH_DIR"
  fi

  export CARDANO_LIB_DIR="$CARDANO_BIN_PATH_DIR/../data/cervino/lib/"
  if [[ ! -d "$CARDANO_LIB_DIR" ]]; then
    usage 9 "cardano lib directory not found"
  fi
fi

export SYCL_LIB_PATH="$(realpath $DRIVER_PATH_DIR/../lib)"

# excluding file extension e.g. .cpp
export SOURCE_FILE_NAME="$3"
# input file name including extensions and path
export INPUT_FILE_NAME="$4"
# Should point to whatever Clang has decided is the temporary directory
export CLANG_TEMPORARY_DIR="$5"
# output file name including extensions and path
export OUTPUT_FILE_NAME="$6"

if [[ ! -d "$CLANG_TEMPORARY_DIR" ]]; then
  usage 12 "the path given for the temporary directory is an invalid directory"
fi

xchesscc_wrapper() {
# Push chess scripts to the front of the path, they're placed inside of a
# chesswrapper folder so we don't have to add the bin to the path. Doing that
# may run the risk of breaking chess tools in weird ways (e.g. finding the
# incorrect assembler).
  export PATH=$DRIVER_PATH_DIR/chesswrappers:$PATH
  CARDANO=$(realpath $CARDANO_BIN_PATH_DIR/../)
  export RDI_DATADIR=$CARDANO/data
  export LD_LIBRARY_PATH=$CARDANO/lib/lnx64.o:$CARDANO_BIN_PATH_DIR/../lnx64/tools/dot/lib:$LD_LIBRARY_PATH
  $UNWAPPED_XCHESSCC $@
}

export XCHESSCC=xchesscc_wrapper
export -f xchesscc_wrapper

# Weirdly the +w argument of the chesscc compiler doesn't dump any of the
# output files into the work directory you supply... it seems to just dump a
# ton of other temporary files there! Useful for debugging perhaps, but not
# useful to keep a sane temporary directory when compiling for 400 tiles
export SOURCE_TEMPORARY_DIR="$(mktemp -d $5/sycl-chess.XXXXXX.${SOURCE_FILE_NAME}/)"

KERNELPROP="${SOURCE_TEMPORARY_DIR}KernelProperties_${SOURCE_FILE_NAME}.bash"
UNMERGED_PROP=$SOURCE_TEMPORARY_DIR/KernelUnmergedProperties_${SOURCE_FILE_NAME}.bash
# -O3 causes over optimization with a simple hello_world.cpp and we end up
# with a trap...
# Run Opt pass to convert our IR into something the chess toolchain can support
# The order of opt passes matters: ChessMassage -> mergefunc ->kernelPropGen
# Maybe passes can be renamed to describe stages better.
cp $INPUT_FILE_NAME $INPUT_FILE_NAME.saved.bc
$OPT -S -O3 -instnamer \
  -ChessMassage -mergefunc -kernelPropGen \
  "$INPUT_FILE_NAME" --sycl-kernel-propgen-output $KERNELPROP \
  --sycl-kernel-unmerged-prop-out $UNMERGED_PROP -o \
  "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernels-optimized.ll"

# Our bash file containing kernel property environment variables is placed in
# the systems temporary directory (or wherever the Clang driver is told is the
# temporary directory) and is postfixed with the source files name. It's
# generated by the kernelPropertiesGen OPT pass.

source "$KERNELPROP"

# Retrieve the unmerged kernel list from ChessMassage. This is used to identify
# how functions are merged. Some brief description of idea as below
# The original unmerged list is as:
#   func1 - func2 - func3 - func4 - func5 - ...
# The merged one looks like:
#   func1 - func4 - ...
source "$UNMERGED_PROP"

# AI Engine .o file containing all kernels for the module
$XCHESSCC +P $(nproc) -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f -c \
  -o "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernel_module.o" \
  "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernels-optimized.ll"

# A function we can fork into child processes to achieve some form of
# parallelism at a higher level than chess itself provides with it's own
# paralleism via +P.
# This is the reason everything is lazily exported as we invoke this via xargs
# and wish to import/inject this scripts environment into its subprocess
# invocations
#
# This is the biggest slowdown in the compilation pipeline right now.
# TODO: The next simplest speedup is to swap to Peano which is several times
# quicker after that if it's still slow or if we do not wish to/cannot swap to
# Peano eventually working out duplicate kernels and removing them is the next
# step. Even if templated most sane kernel code is unlikely to have 400
# variations, if it does then may the implementer fall apon the sword of their
# own making!
chess_kernel_compile () {
    set -e
    set -x
    echo "Linking Kernel: $0"
    echo "Tile Main File: $SOURCE_TEMPORARY_DIR/$0.cpp"

    # TODO: Look into the fact that SemaSYCL generates the main files twice
    # once pre-linker phase and once after. This is probably normal behaviour
    # but we do not want to be unable to clean up those files and it may result
    # in some unusual behaviour longterm
    mv "$CLANG_TEMPORARY_DIR/$0.cpp" "$SOURCE_TEMPORARY_DIR/$0.cpp"

    $XCHESSCC -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f -c \
      -o "$SOURCE_TEMPORARY_DIR/$0.main.o" "$SOURCE_TEMPORARY_DIR/$0.cpp"

    # link the same kernel for west tiles and east tiles
    $XCHESSCC -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f \
      +l$DRIVER_PATH_DIR/chesswrappers/linker_script_east.bcf \
      -o "$SOURCE_TEMPORARY_DIR/$0.elf.o_east" \
      "$SOURCE_TEMPORARY_DIR/$0.main.o" \
      "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernel_module.o" \
      "$SYCL_LIB_PATH/acap-intrinsic.o"

    $XCHESSCC -p me -C Release_LLVM -P $CARDANO_LIB_DIR -d -f \
      +l$DRIVER_PATH_DIR/chesswrappers/linker_script_west.bcf \
      -o "$SOURCE_TEMPORARY_DIR/$0.elf.o_west" \
      "$SOURCE_TEMPORARY_DIR/$0.main.o" \
      "$SOURCE_TEMPORARY_DIR/${SOURCE_FILE_NAME}_kernel_module.o" \
      "$SYCL_LIB_PATH/acap-intrinsic.o"
}

# export the bash function so xargs can use it
export -f chess_kernel_compile

# For the number of arguments in KERNEL_NAME_ARRAY, invoke xargs for each
# and only consume 1 argument per invocation. This is passed in as the $0'th
# variable. We invoke xargs for the maximum number of cores available on the
# system.
if [[ ! ${#KERNEL_NAME_ARRAY[@]} -eq 0 ]]; then
  echo "Building ${#KERNEL_NAME_ARRAY[@]} Kernels..."
  echo "${KERNEL_NAME_ARRAY[@]}" | xargs -n1 -P$(nproc) \
    bash -c 'chess_kernel_compile "$@"'
fi

# Wait on all our spawned compilations to complete
wait

# Cat all the metadata and images into a file (essentially defining our own
# temporary packing format). This is perhaps not robust but it does the job for
# the moment.
# This is not parallelized in the compilation function as we want the file to be
# sequential or at least in the basic order defined in the loop. We do not want
# data races making the file format non-deterministic.
if [[ ! ${#KERNEL_NAME_ARRAY_UNMERGED[@]} -eq 0 ]]; then
  LINKER_LIST=""
  # This merged_index is index to KERNEL_NAME_ARRAY[]. It points to the kernel
  # that duplicate kernels are merged into. In below example, kernel1 and
  # kernel2 are merged into kernel0.
  #   unmerged: kernel0 - kernel1 - kernel2 - kernel3
  #   merged:   kernel0 - kernel3
  # While iterating the unmerged kernel list below, if the corresponding elf
  # doesn't exist, it means the kernel has been merged, hence the other kernel
  # pointed by merged_index is used instead. When the elf exists, merged_index
  # increments to update and point to correct merged kernel.
  merged_index=-1;
  for index in "${KERNEL_NAME_ARRAY_UNMERGED[@]}"; do
    if [[ -n "$index" ]]; then
      # Search for the corresponding elf file. If the file doesn't exist,
      # that means the kernel has been merged into previous matched one.
      # This is valid because all in KERNEL_NAME_ARRAY* are identically sorted
      # with hash values.
      ELF="$SOURCE_TEMPORARY_DIR/${index}.elf.o"

      # both ${ELF}_east and ${ELF}_west are always created at the same time
      # so checking for one of them check that both are here.
      if [ ! -f "${ELF}_east" ]; then
        ELF="$SOURCE_TEMPORARY_DIR/${KERNEL_NAME_ARRAY[$merged_index]}.elf.o"
      else
        set +e
        ((merged_index++))
        set -e
      fi

      for POSTFIX in _east _west; do
        # Name of ELF binary and kernel function that we will synch with
        # integration header to retrieve our binary, it will be packaged as part
        # of the final image data.
        # The name is also used by the Offload Wrapper to identify the image to
        # wrap into the host binary after its loaded into memory.
        echo "${index}$POSTFIX" >> "$OUTPUT_FILE_NAME"
        
        # Size of file in bytes
        echo "`ls -lrt "${ELF}$POSTFIX" | nawk '{print $5}'`" >> "$OUTPUT_FILE_NAME"
        cat ${ELF}$POSTFIX >> "$OUTPUT_FILE_NAME"
      done
    fi
  done
fi
# Dump a copy of the file containing all of the AIE binaries into another file
# so that we can introspect and in theory skip the AOC stage above, if
# we want to, by altering the script a little to comment out the compilation
# steps and inverting the copy, to copy the aie_images file to the output file.
# Useful for debugging the host <-> device side mapping and or offloading
# stages. Dumped in the basic temporary directory clang passes because we
# flatline all of the directory we use to output intermediate files.
cp "$OUTPUT_FILE_NAME" "$CLANG_TEMPORARY_DIR/aie_images-$USER"

# Delete all temporary files generated by Chess and other tools, the clang
# compiler doesn't know what we generate in here so it has to be manually
# tracked and removed
# rm -rf $SOURCE_TEMPORARY_DIR
